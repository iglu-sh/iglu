
/*
This endpoint is used to register a new builder node to this controller. The node will send a registration request to this endpoint
with the following body:
{
  node_name: string, // The name of the node (randomly generated or set by the user)
  node_psk: string, // The pre-shared key for the node (generated by the node and hashed when we get it here so we can store it in the database without any trouble)
  node_address: string, // The address of the node (IP or domain)
  node_port: number, // The port of the node
  node_version: string, // The version of the node
  node_arch: string, // The architecture of the node (x86_64, arm64, etc.)
  node_os: string, // The operating system of the node (Linux, Darwin, etc.)
  node_max_jobs: number, // The maximum number of jobs the node can handle at once
}
*/
import type {NextRequest} from "next/server";
import type {nodeRegistrationRequest, nodeRegistrationResponse} from "@iglu-sh/types/scheduler";
import {z} from "zod";
import * as crypto from "node:crypto";
import Logger from "@iglu-sh/logger";
import Database from "@/lib/db";

export async function POST(request:NextRequest){
    Logger.debug(`Received request to register node`);
    if(!request.headers.has("Authorization") || request.headers.get("Authorization") !== process.env.NODE_PSK){
        return new Response(JSON.stringify({message: "Unauthorized"}), {
            status: 401,
            headers: {
                "Content-Type": "application/json"
            }
        });
    }
    if(!request.body){
        return new Response(JSON.stringify({message: "Bad Request", cause: "No body provided"}), {
            status: 400,
            headers: {
                "Content-Type": "application/json"
            }
        });
    }
    const body = await request.json() as Record<string, unknown>;
    // Create a zod schema from the nodeRegistrationRequest type
    const nodeRegistrationSchema = z.object({
        node_name: z.string(),
        node_psk: z.string(),
        node_address: z.string(),
        node_port: z.number(),
        node_version: z.string(),
        node_arch: z.string(),
        node_os: z.string(),
        node_max_jobs: z.number()
    });
    // Validate the body against the schema
    const parsedBody = nodeRegistrationSchema.safeParse(body);
    if(!parsedBody.success){
        return new Response(JSON.stringify({message: "Bad Request", cause: parsedBody.error.message}), {
            status: 400,
            headers: {
                "Content-Type": "application/json"
            }
        });
    }
    const nodeData:nodeRegistrationRequest = parsedBody.data;

    // Generate a random node ID
    const nodeId = crypto.randomUUID();

    // Send the nodeId to the node
    const response:nodeRegistrationResponse = {
        node_id: nodeId
    }
    // Insert node into db
    const db = new Database()
    try {
        await db.connect()
        await db.createNode(nodeData, nodeId)
        await db.disconnect()
    }
    catch(e){
        await db.disconnect()
        Logger.error(`Failed to register node: ${e}`);
        return new Response(JSON.stringify({message: "Internal Server Error"}), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        })
    }
    Logger.info(`Node ${nodeData.node_name} registered with ID ${nodeId}`);
    return new Response(JSON.stringify(response), {
        status: 200,
        headers: {
            "Content-Type": "application/json"
        }
    });
}